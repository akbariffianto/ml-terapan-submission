# -*- coding: utf-8 -*-
"""Anime Recomender.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lATqoByF64jBBQWC6MATyVQ9Gdm7brxI
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
from zipfile import ZipFile
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
from pathlib import Path
import matplotlib.pyplot as plt
# %matplotlib inline
import seaborn as sns

"""# Load Data

Langkah pertama yang dilakukan adalah meload dataset yang akan digunakan, dalam projek kali ini akan menggunakan dataset dengan tema anime atau kartun dari negara jepang
"""

anime = pd.read_csv('/content/anime.csv')
rating = pd.read_csv('/content/rating.csv')

"""Masing masing dataset diberi nama sesuai dengan nama dataset untuk mempermudah langkah selanjutnya

Dataset dengan nama anime memiliki kolom anime_id, name, genre, type, episodes, rating, dan members
"""

rating.head()

"""Dataset dengan nama rating memiliki kolom user_id, anime_id, dan rating"""

print('Jumlah data anime: ', len(anime.name.unique()))
print('Jumlah data rating: ', len(rating.user_id.unique()))

"""Dapat disimpulkan dataset memiliki jumlah judul anime sebanyak 12292 dan jumlah user sebanyak 73515

# EDA

## Anime

### Deskripsi Variabel
"""

anime.head()

"""Variabel pada data anime:
- anime_id : Index setiap anime
- name : Judul anime
- genre : Genre anime
- type : Jenis penyiaran
- episodes : Jumlah episode
- rating : Rating anime
- Members : Jumlah member yang bergabung ke dalam komunitas
"""

anime.info()

"""Berdasarkan output diatas dapat disimpulkan dataset anime memiliki entri sebanyak 12294. Namun terdapat null value di beberapa variabel. Tindakan cleaning data perlu dilakukan.

### Univariate Analysis

Untuk dapat melihat berapa jumlah judul anime dengan yang bersifat unik maka akan menggunakan unique()
"""

print('Jumlah anime: ', len(anime.name.unique()))

"""Berikut kode yang akan menampilkan distribusi data rating pada data anime, untuk melihat trend dan konsentrasi di nilai tertentu"""

plt.figure(figsize=(8, 6))
sns.histplot(anime['rating'].dropna(), kde=True)
plt.title('Distribution of Anime Ratings')
plt.xlabel('Rating')
plt.ylabel('Frequency')
plt.show()

max_rating = rating['rating'].max()
mean_rating = rating['rating'].mean()
min_rating = rating['rating'].min()

print(f"Max Rating: {max_rating}")
print(f"Mean Rating: {mean_rating}")
print(f"Min Rating: {min_rating}")

"""Dapat disimpulkan rating memiliki nilai dari rentang -1 sampai 10, rata-rata rating yang diberikan ada di angka 6 sedangkan rating paling minimum adalah -1 dimana nilai -1 meiliki makna member tidak memberikan nilai walaupun sudah menonton anime tersebut."""

plt.figure(figsize=(8, 6))
sns.histplot(anime['episodes'].dropna(), kde=True, orientation='vertical')
plt.title('Distribution of Anime Episodes')
plt.ylabel('Frecuency')
plt.xlabel('Episodes')
plt.show()

print('Jumlah episode anime: ', len(anime.episodes.unique()))

top_10_episodes = anime['episodes'].value_counts().nlargest(10)
top_10_episodes

"""Anime mayoritas memiliki episode 1 yang mana anime episode 1 adalah anime dengan jenis penyiaran movie"""

plt.figure(figsize=(10, 6))
sns.countplot(x='type', data=anime)
plt.title('Distribution of Anime Types')
plt.xlabel('Anime Type')
plt.ylabel('Count')
plt.xticks(rotation=45)
plt.show()

"""Dari distribusi tipe penyiaran anime, tipe anime yang jumlahnya paling banyak adalah TV."""

genre_counts = anime['genre'].str.split(',').explode().value_counts().head(10)
plt.figure(figsize=(12, 6))
sns.barplot(x=genre_counts.index, y=genre_counts.values)
plt.title('Top 10 Anime Genres')
plt.xlabel('Genre')
plt.ylabel('Count')
plt.xticks(rotation=45)
plt.show()

"""Dari distribusi diatas dapat disimpulkan bahwa genre comedy menjadi genre paling terbanyak dalam anime. Karena genre anime memiliki variasi yang bagus maka dalam merekomendasikan anime nantinya akan memberikan akurasi yang tinggi bagi pengguna sistem rekomendasi."""

unique_genres = []
for index in anime.index:
    genres = anime.loc[index, 'genre']
    if isinstance(genres, str):
      for genre in genres.split(','):
        genre = genre.strip()
        if genre not in unique_genres:
          unique_genres.append(genre)

print("Jumlah unik genre:", len(unique_genres))

top_10_members = anime.sort_values(by='members', ascending=False).head(10)
top_10_members

"""Death Note menjadi anime yang paling populer dikarenakan jumlah membersnya paling banyak diantara judul anime lainnya.

### Multivariate Analysis
"""

members_rating_corr = anime['members'].corr(anime['rating'], method='spearman')
plt.figure(figsize=(6, 4))
sns.heatmap(anime[['members', 'rating']].corr(method='spearman'), annot=True, cmap='coolwarm', fmt=".2f")
plt.title('Spearman Correlation Heatmap: Members vs. Rating')
plt.show()

"""Fitur rating dan members memiliki skor korelasi yang cukup tinggi yaitu diatas 50%. Hal ini masuk akal dikarenakan anime dengan rating yang tinggi kebanyakan memiliki jumlah members yang tinggi juga. Semakin tinggi rating maka akan semakin populer anime tersebut. Banyak dari platform situs streaming online anime, anime dengan rating paling tinggi selalu ditampilkan di halaman pertama yang menunjukan rating dijadikan sebagai variabel rekomendasi non-personalized kebanyakan platform streaming anime."""

plt.figure(figsize=(10, 6))
sns.boxplot(x='type', y='rating', data=anime)
plt.title('Rating Distribution by Anime Type')
plt.xlabel('Anime Type')
plt.ylabel('Rating')
plt.xticks(rotation=45)
plt.show()

"""- Anime dengan tipe Movie dan TV cenderung mendapatkan rating yang lebih tinggi dan lebih konsisten dibandingkan tipe lainnya.
- Anime dengan tipe Music cenderung mendapatkan rating yang lebih rendah.
- Tipe OVA, Special, dan ONA memiliki variasi rating yang lebih besar dan cenderung memiliki beberapa anime dengan rating yang sangat rendah.
- Keberadaan outlier menunjukkan adanya beberapa anime dengan rating yang sangat tinggi atau sangat rendah di setiap tipe.

### Data Preparation

#### Cleaning Data

Menanggani missing value adalah hal yang tepat untuk mengembangkan model yang akurat. Sebelum menangganinya, penting untuk mencari baris data yang bernilai null.
"""

anime.isna().sum()

"""Berdasarkan informasi diatas, genre, type, dan rating memiliki nilai null. Langkah yang paling tepat menanggani missing value dalam proyek ini adalah menghapusnya. Alasannya adalah untuk meminimalkan sistem rekomendasi bias pada ke variabel tertentu. Baris yang dihapus hanyalah baris yang memiliki value null di fitur genre. Karena genre akan digunakan sebagai item di sistem content based filtering

"""

anime.dropna(subset=['genre'], inplace=True)

anime.isna().sum()

"""Baris data dengan missing value di fitur genre berhasil dihapus.

Selain missing value, drop data yang duplikat juga akan membuat model lebih akurat. Namun penangganannya harus diperhatikan. Agar setiap baris data anime mewakilkan satu judul anime. Maka hal yang paling tepat adalah menghapus data dupliat hanya pada fitur name.
"""

anime.drop_duplicates('name')

anime.shape

"""Dari proses membersihkan data yang duplikat dan memiliki value null dataset anime memiliki entri sebanyak 12294

#### Feature Engineering

Dataset anime akan digunakan dalam model content based filtering berdasarkan genre tiap judul anime. Oleh karena itu, dalam pengembangan modelnya hanya membutuhkan anime_id, name, dan genre.
"""

cbf_anime = anime[['anime_id', 'name', 'genre']]
cbf_anime.head()

cbf_anime.loc[cbf_anime['genre'].str.contains('Sci-Fi', na=False), 'genre'] = cbf_anime['genre'].str.replace('Sci-Fi', 'scifi')
cbf_anime.loc[cbf_anime['genre'].str.contains('Slice of Life', na=False), 'genre'] = cbf_anime['genre'].str.replace('Slice of Life', 'sliceoflife')

cbf_anime.head()

"""Penggunaan `TfidfVectorizer` dari scikit-learn untuk memproses genre anime, input yang paling umum dan efisien adalah list string (di mana setiap string mewakili genre anime). Maka perlu dilakukan pengoversian data ke bentuk list."""

# Mengonversi data series ‘anime_id’ menjadi dalam bentuk list
anime_id = cbf_anime['anime_id'].tolist()

# Mengonversi data series 'name' menjadi dalam bentuk list
anime_name = cbf_anime['name'].tolist()

# Mengonversi data series 'genre' menjadi dalam bentuk list
anime_genre = cbf_anime['genre'].tolist()

"""# Content Based Filtering"""

# Membuat dictionary untuk data , 'anime_id', 'name', 'genre'
fix_anime = pd.DataFrame({
    'id': anime_id,
    'name': anime_name,
    'genre': anime_genre
})
fix_anime.head()

"""## One-Hot Encoding

Sebelum menggunakan `TfidfVectorizer` untuk processing fitur, perlu dilakukannya one-hot encoding atau mengubah fitur kategori ke fitur numerik. Output dari hadil one-hot encoding adalah kolom fitur genre anime dengan nilai dari 0-1.
"""

genre_list = []

# Membuat daftar genre unik
for index in fix_anime.index:
    temp = fix_anime['genre'][index].split(',')
    for i in temp:
        if i not in genre_list:
            genre_list.append(i)

onehot_df = pd.DataFrame(0, index=fix_anime.index, columns=genre_list)

# Mengisi nilai 1 untuk genre yang sesuai
for index in fix_anime.index:
    temp = fix_anime['genre'][index].split(',')
    for i in temp:
        onehot_df.loc[index, i] = 1

fix_anime = pd.concat([fix_anime, onehot_df], axis=1).fillna(0)
print(fix_anime.head())

"""## TF-IDF Vectorizer

Kode ini mengubah data genre anime dari representasi teks menjadi representasi numerik menggunakan metode TF-IDF. TF-IDF memberikan bobot pada setiap term dalam setiap dokumen, dengan mempertimbangkan frekuensi term dalam dokumen tersebut (TF) dan seberapa langka term tersebut di seluruh dokumen (IDF). Hasilnya adalah representasi numerik dari genre anime yang dapat digunakan sebagai input untuk model machine learning.
"""

from sklearn.feature_extraction.text import TfidfVectorizer

# Inisialisasi TfidfVectorizer
tf = TfidfVectorizer()

# Melakukan perhitungan idf pada data genre
tf.fit(fix_anime['genre'])

# Mapping array dari fitur index integer ke fitur nama
tf.get_feature_names_out()

# Melakukan fit lalu ditransformasikan ke bentuk matrix
tfidf_matrix = tf.fit_transform(fix_anime['genre'])

# Melihat ukuran matrix tfidf
tfidf_matrix.shape

# Mengubah vektor tf-idf dalam bentuk matriks dengan fungsi todense()
tfidf_matrix.todense()

# Membuat dataframe untuk melihat tf-idf matrix
# Kolom diisi dengan jenis masakan
# Baris diisi dengan nama anime

pd.DataFrame(
    tfidf_matrix.todense(),
    columns=tf.get_feature_names_out(),
    index=fix_anime.name
).sample(22, axis=1).sample(10, axis=0)

"""## Cosine Similarity"""

from sklearn.metrics.pairwise import cosine_similarity

# Menghitung cosine similarity pada matrix tf-idf
cosine_sim = cosine_similarity(tfidf_matrix)
cosine_sim

"""- `from sklearn.metrics.pairwise import cosine_similarity:` Baris ini mengimpor fungsi cosine_similarity dari modul metrics.pairwise dalam library scikit-learn. Fungsi ini digunakan untuk menghitung similaritas kosinus antara dua matriks atau vektor.

- `cosine_sim = cosine_similarity(tfidf_matrix)`: Baris ini adalah inti dari perhitungan similaritas kosinus.

  - `cosine_similarity(tfidf_matrix)`: Fungsi ini menerima sebuah matriks sebagai input, dalam hal ini tfidf_matrix. tfidf_matrix diasumsikan sebagai matriks TF-IDF yang dihasilkan sebelumnya menggunakan TfidfVectorizer. Setiap baris dalam matriks ini merepresentasikan sebuah dokumen (dalam konteks sebelumnya, mungkin sebuah anime), dan setiap kolom merepresentasikan sebuah term (kata atau n-gram). Nilai dalam matriks adalah bobot TF-IDF untuk setiap term dalam setiap dokumen.
  - Fungsi `cosine_similarity` menghitung similaritas kosinus antara semua pasangan baris dalam matriks tfidf_matrix.
  - `cosine_sim`: Hasil dari cosine_similarity disimpan dalam variabel `cosine_sim`. cosine_sim akan berupa matriks persegi. Ukuran matriks ini adalah N x N, di mana N adalah jumlah dokumen (jumlah baris dalam tfidf_matrix). Setiap elemen cosine_sim[i][j] berisi similaritas kosinus antara dokumen i dan dokumen j.
"""

# Membuat dataframe dari variabel cosine_sim dengan baris dan kolom berupa nama anime
cosine_sim_df = pd.DataFrame(cosine_sim, index=fix_anime['name'], columns=fix_anime['name'])
print('Shape:', cosine_sim_df.shape)

# Melihat similarity matrix pada setiap anime
cosine_sim_df.sample(5, axis=1).sample(10, axis=0)

"""## Euclidean Distance"""

from sklearn.metrics.pairwise import euclidean_distances

euclidean_sim = euclidean_distances(tfidf_matrix)
euclidean_sim

euclidean_sim_df = pd.DataFrame(euclidean_sim, index=fix_anime['name'], columns=fix_anime['name'])
print('Shape:', euclidean_sim_df.shape)

euclidean_sim_df.sample(5, axis=1).sample(10, axis=0)

"""1. `from sklearn.metrics.pairwise import euclidean_distances`: Baris ini mengimpor fungsi euclidean_distances dari sklearn.metrics.pairwise. Fungsi ini digunakan untuk menghitung jarak Euclidean antar baris dalam sebuah matriks.

2. `euclidean_sim = euclidean_distances(tfidf_matrix)`: Baris ini menghitung jarak Euclidean.
  - `euclidean_distances(tfidf_matrix)`: Fungsi ini mengambil matriks TF-IDF (`tfidf_matrix`) sebagai input. Sama seperti sebelumnya, matriks ini merepresentasikan dokumen (anime) sebagai vektor dalam ruang TF-IDF.
  - Fungsi ini menghitung jarak Euclidean antara setiap pasangan baris dalam `tfidf_matrix`. Jarak Euclidean mengukur "jarak garis lurus" antara dua titik dalam ruang vektor.
  - `euclidean_sim`: Hasilnya disimpan dalam variabel euclidean_sim. Ini akan berupa matriks persegi N x N, di mana N adalah jumlah dokumen. euclidean_sim[i][j] berisi jarak Euclidean antara dokumen i dan dokumen j.
3. `euclidean_sim_df = pd.DataFrame(euclidean_sim, index=fix_anime['name'], columns=fix_anime['name'])`: Baris ini mengubah matriks jarak Euclidean menjadi DataFrame Pandas.
  - `pd.DataFrame(euclidean_sim, ...):` Ini membuat DataFrame baru dari matriks `euclidean_sim.`
`index=fix_anime['name']`: Ini menetapkan indeks baris DataFrame menggunakan nama anime dari kolom 'name' di DataFrame fix_anime. Ini sangat berguna karena sekarang kita dapat mengakses jarak berdasarkan nama anime, bukan hanya indeks numerik.
`columns=fix_anime['name']`: Ini menetapkan nama kolom DataFrame juga menggunakan nama anime.
print('Shape:', euclidean_sim_df.shape): Baris ini mencetak dimensi (shape) dari DataFrame euclidean_sim_df. Ini akan menampilkan jumlah baris dan kolom, yang keduanya akan sama dengan jumlah anime.

3. `euclidean_sim_df.sample(5, axis=1).sample(10, axis=0)`: Baris ini menampilkan sampel acak dari DataFrame.
  - `.sample(5, axis=1)`: Ini memilih 5 kolom (anime) secara acak. axis=1 menunjukkan bahwa kita memilih kolom.
  - `.sample(10, axis=0)`: Ini kemudian memilih 10 baris (anime) secara acak dari hasil pemilihan kolom sebelumnya. axis=0 menunjukkan bahwa kita memilih baris.
  - Rangkaian `.sample()` ini menghasilkan tampilan sebagian kecil dari DataFrame, yang berguna untuk memeriksa beberapa nilai tanpa harus melihat seluruh matriks yang mungkin sangat besar.

## Mendapatkan Rekomendasi
"""

cbf_anime[cbf_anime.name.eq('Naruto')]

def anime_cosine(nama_anime, similarity_data=cosine_sim_df, items=fix_anime[['name', 'genre']], k=10):
    """
    Rekomendasi Anime berdasarkan kemiripan Genre

    Parameter:
    ---
    nama_anime : tipe data string (str)
                Nama anime (index kemiripan dataframe)
    similarity_data : tipe data pd.DataFrame (object)
                      Kesamaan dataframe, simetrik, dengan anime sebagai
                      indeks dan kolom
    items : tipe data pd.DataFrame (object)
            Mengandung kedua nama dan fitur lainnya yang digunakan untuk mendefinisikan kemiripan
    k : tipe data integer (int)
        Banyaknya jumlah rekomendasi yang diberikan
    ---


    Pada index ini, kakan diambil dengan nilai similarity terbesar
    pada index matrix yang diberikan (i).
    """


    # Mengambil data dengan menggunakan argpartition untuk melakukan partisi secara tidak langsung sepanjang sumbu yang diberikan
    # Dataframe diubah menjadi numpy
    # Range(start, stop, step)
    index = similarity_data.loc[:,nama_anime].to_numpy().argpartition(
        range(-1, -k, -1))

    # Mengambil data dengan similarity terbesar dari index yang ada
    closest = similarity_data.columns[index[-1:-(k+2):-1]]

    # Drop name agar nama anime yang dicari tidak muncul dalam daftar rekomendasi
    closest = closest.drop(nama_anime, errors='ignore')

    return pd.DataFrame(closest).merge(items).head(k)

# Mendapatkan rekomendasi anime yang mirip
anime_cosine('Naruto')

"""Dari kesepuluh anime yang direkomendasikan, semuanya relevan dan memiliki genre yang mirip, bisa disimpulkan nilai precisionnya seperti berikut:
```
P = 10 / 10
p = 1
```
Model memiliki keakuratan yang sangat akurat dalam merekomendasikan anime berdasarkan genre.
"""

def anime_euclidean(nama_anime, similarity_data=euclidean_sim_df, items=fix_anime[['name', 'genre']], k=10):
    """
    Rekomendasi Anime berdasarkan jarak Euclidean

    Parameter:
    ---
    nama_anime : tipe data string (str)
                Nama anime (index kemiripan dataframe)
    similarity_data : tipe data pd.DataFrame (object)
                      Kesamaan dataframe, simetrik, dengan anime sebagai
                      indeks dan kolom
    items : tipe data pd.DataFrame (object)
            Mengandung kedua nama dan fitur lainnya yang digunakan untuk mendefinisikan kemiripan
    k : tipe data integer (int)
        Banyaknya jumlah rekomendasi yang diberikan
    ---
    Pada index ini, k akan diambil dengan nilai Euclidean distance terkecil
    pada index matrix yang diberikan (i).
    """

    # Mengambil data dengan menggunakan argpartition untuk melakukan partisi secara tidak langsung sepanjang sumbu yang diberikan
    # Dataframe diubah menjadi numpy
    index = similarity_data.loc[:, nama_anime].to_numpy().argpartition(range(k))

    # Mengambil data dengan Euclidean distance terkecil dari index yang ada
    closest = similarity_data.columns[index[:k]]

    # Drop name agar nama anime yang dicari tidak muncul dalam daftar rekomendasi
    closest = closest.drop(nama_anime, errors='ignore')

    # Membuat DataFrame hasil
    result_euclidean = pd.DataFrame(closest).merge(items).head(k)

    # Return DataFrame hasil
    return result_euclidean

anime_euclidean('Naruto')

"""Dari kesepuluh anime yang direkomendasikan, semuanya relevan dan memiliki genre yang mirip, bisa disimpulkan nilai precisionnya seperti berikut:
```
P = 10 / 10
p = 1
```
Model memiliki keakuratan yang sangat akurat dalam merekomendasikan anime berdasarkan genre.
"""